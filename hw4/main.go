package main

import (
	"fmt"
	"math/big"
)

const debug = false

func Debug(f string, v ...interface{}) {
	if debug {
		fmt.Printf(f, v...)
	}
}

// quiz 3
// func main() {
// 	a := big.NewInt(141)
// 	b := big.NewInt(162)
// 	p := big.NewInt(163)
// 	g := &Point{big.NewInt(6), big.NewInt(88)}
// 	n := big.NewInt(3)

// 	// n := big.NewInt(3)
// 	ec := &EllipicCurve{a, b, p}

// 	fmt.Println("Ellipic Curve:", ec)
// 	fmt.Println("G:", g, "isOnCurve:", ec.IsOnCurve(g))
// 	nG := ec.ScalarMult(n, g)
// 	fmt.Println("N*G:", nG, "isOnCurve:", ec.IsOnCurve(nG))

// 	// halfmask = (80, 7) = aG = 121G
// 	alice := big.NewInt(121)
// 	h := ec.ScalarMult(alice, g)

// 	fmt.Println("Halfmask:", h, "isOnCurve:", ec.IsOnCurve(h))

// 	// full mask = n * h = naG
// 	f := ec.ScalarMult(n, h)
// 	fmt.Println("Fullmask:", f, "isOnCurve:", ec.IsOnCurve(f))

// 	// cipher = (88, 71) = naG + m
// 	c := &Point{big.NewInt(88), big.NewInt(71)}

// 	// m = C - naG
// 	plain := ec.Sub(c, f)

// 	// plain text = cipher - fullmask
// 	fmt.Println("Plaintext:", plain, "isOnCurve:", ec.IsOnCurve(plain))

// 	// Find the period of G
// 	// fmt.Println("Period of G:", ec.Order(g))
// }

func main() {
	prime := new(big.Int).SetBytes([]byte("174095479503494089102058402505908788526019855967814733438804231465527914236968890087228697246515264224322503055783534528662224009081611092996674253475185752520899827021681967540300771276892724730319418183769434750966095824878115428477581852963792200892639286552224381277542684670030837107722916532530306445627"))
	a := new(big.Int).SetBytes([]byte("143483245795638707551267552184379962067040033512960921992150010173202247040354852774943436232391421717838891658118196641056354280985065856972231601779092668463669354166526067156034281782417731181420705449858208706324785090710591561984275182447109292993821938120298787404593160265850171472866647284875420029812"))
	b := new(big.Int).SetBytes([]byte("139307549401954230856768283399350471603133409148221184511104737799033389622043155712164066064801957631438958040705862962836609320600922142669396786995577401917097003968447218062821008292841659880184187667554522752078266695877216687580215538954550068658717726516354475264312232158552444602287729985372396023136"))

	g, ok := new(Point).SetString("130447584713533089669485336499797623711718217646936619123075344574242625806578200727428590677881516241536770719234403972703741916958934661079197960759179218091473258130355882694572756809917629513273179869558257494919289390293653029584582045451031663753161303870419548724709216634960661058624230596671750596755", "32821889565262848566990262994158154358613342758848117165049452505083787784423217623477427538438200634243879122800333318183736594173577047326767004066294824410810217901788436161538924913172849257216860956419971325757351102619605356957939840722018179623157539666714997292059028102329658217489670547868771372492")
	if !ok {
		panic("failed to parse G")
	}

	point, ok := new(Point).SetString("74884380633085228732474398446921943991669332308532852030130605789717214261250433917853465804043590520103353981368781367472504171334152438354526427693594007421500892888249108732508735521772781756143060916018049576729583209510448313445766836217664624894490946058859573723544619725567021287881821438938754695896", "4652941727865479407835146809932615539990654737868522612906089526446328908856435010548845665992142959452158137152771918198742277156557656938193792754726237919423435396449178527654046549955076808195812509712040378995755080798679605170006280581573476645276003333933786311028523032862161729264168059991087251784")
	if !ok {
		panic("failed to parse point")
	}

	// multiplier := big.NewInt(3)

	ec := &EllipicCurve{a, b, prime}

	// test if g and point are on the curve
	fmt.Println("g is on curve:", ec.IsOnCurve(g))
	fmt.Println("point is on curve:", ec.IsOnCurve(point))

}
